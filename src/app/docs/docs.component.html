<div class="content">
  <h1>NgRx Life Cycle</h1>
</div>

<section>
  <h2>The Redux Way</h2>

  <div>
    <h3>Decentralized State</h3>
    <p>
      Modern web applications are represented as a complex tree of components
      that constantely produce and share data, called:
      <strong>state</strong>.
      <br />
      When state is decentralized it can become difficult to understand and
      manage.
      <br />
      <img
        src="/assets/components-tree.png"
        alt="Components tree"
        class="my-4"
      />
    </p>
  </div>

  <div>
    <h3>Single Global State: The Store</h3>
    <p>
      Redux introduces a global state - called <strong>store</strong> - for all
      the data. It relies on a single immutable object to store all of the
      application data - like a client-side database.
      <br />
      The store is the
      <strong>single source of truth</strong> for all the data in your
      application
      <img src="/assets/redux-pattern.png" alt="Components tree" class="my-4" />
    </p>
  </div>
</section>
<section>
  <h2>NgRx Implementation</h2>
  <img
    src="https://ngrx.io/generated/images/guide/store/state-management-lifecycle.png"
    alt="NgRx Life Cycle"
  />

  <div>
    <h3>Components and Actions</h3>
    <p>
      Component should not worry about how to manage the state if something
      happens. It doesn't need to know which services to inject or methods to
      call to get the job done.
    </p>

    <p>
      If a user clicks on the delete button the component only needs to
      communicate: "Hey, someone clicked on the delete button for this Todo." A
      component <strong>only dispatches an action</strong> to indicate that
      something happened.
    </p>

    <p>Components are responsible for <strong>rendering</strong> the state.</p>
    <p>
      Components are <strong>subscribed</strong> to the store and
      <strong>select</strong> slices of the state.
    </p>
    <p>
      Components are <strong>dispatching actions</strong> to the store, which
      then updates the state.
    </p>
  </div>
  <div>
    <h3>Reducers</h3>
    <p>
      Actually responible to determine
      <strong>how actions should modify state</strong> are the reducers
    </p>
    <p>
      Usually we would have one reducer for each feature or entity in the app,
      like todos or articles or such.
    </p>
    <p>
      A reducer takes the <strong>action and the current state</strong> and
      saves the new state in the store.
    </p>
    <p>
      An important concept is that reducers are <strong>pure functions</strong>:
    </p>
    <ul class="list">
      <li>Given the same input they always produce the same output</li>
      <li>
        They should not produce any side effects. That is to say the functions
        should not change anything anywhere else in the app.
      </li>
    </ul>
  </div>
  <div>
    <h3>Store</h3>
    <p>
      The store is where all the information of your application lives. It is
      responsible for <strong>holding the state</strong> and is in fact only one
      big object full of data.
    </p>
    <p>
      The store is <strong>immutable</strong> and <strong>read-only</strong>.
    </p>
    <p>
      The store is <strong>updated</strong> by
      <strong>dispatching actions</strong> to the store, which then updates the
      state.
    </p>
  </div>

  <div>
    <h3>Selectors</h3>
    <p>
      When a component wants to use some of that store it can use a selector to
      pull in the state that it needs from the store.
    </p>
    <p>
      Selectors are <strong>used in components</strong> to get the data they
      need.
    </p>
    <p>
      Selectors are responsible for <strong>selecting</strong> slices of the
      state.
    </p>
    <p>
      Selectors are <strong>pure functions</strong> that take the state and
      return a slice of it.
    </p>
  </div>

  <div>
    <h3>Effects</h3>

    <p>
      Because reducers must not produce any side effects and cannot call a
      service to fetch data, we need another way to do that. That is where
      effects come in.
    </p>

    <p>
      Effects are responsible for <strong>side effects</strong> like fetching
      data from the server, logging to the console, or routing to a new page.
    </p>
    <p>
      Effects are the only place where you can
      <strong>perform side effects</strong> like interacting with a server,
      logging to the console, or routing to a new page.
    </p>
    <p>
      Effects also listen to <strong>actions</strong> and
      <strong>dispatch</strong> new actions once the side effect is complete.
    </p>
    <p>
      Effects are <strong>dispatching actions</strong> to the store, which then
      updates the state.
    </p>
  </div>
</section>


<section>
  <h2>Real Life Analogy</h2>

  <div class="content">
    <img
      src="assets/5ztp5hs0bcz7hw753ugh.png"
      alt="Simple real life example"
      class="inline-block center"
    />
  </div>

  <ol>
    <li>
      <h4>Step 1</h4>
      <p class="text-xl">
        At the convenience of home, people can order food by calling restaurant
        workers.
      </p>
    </li>
    <li>
      <h4>Step 2</h4>
      <p class="text-xl">
        Restaurant workers notes down your order and then hands it off to chef.
        They also get groceries if needed for the order.
      </p>
    </li>
    <li>
      <h4>Step 3</h4>
      <p>Chef cooks the orders and places them in the store display.</p>
    </li>
    <li>
      <h4>Step 4</h4>
      <p>
        The delivery man picks up respective orders from store and delivers it
        to people like you.
      </p>
    </li>
  </ol>

  <blockquote>
    Notice that during all these steps, all you have done is just requesting
    which item you want. Everything else is within its eco system and each
    member has specific job to do.
  </blockquote>
</section>
